# 数组和字符串

## 数组

### 集合，列表，数组

> 集合

定义:一个或者多个确定元素构成的整体

特点：

1. 集合里面元素类型不一定相同
2. 集合里面的元素没有顺序

> 列表

定义：按照一定的线性顺序，排列而成的数据项的集合

特点：

1. 具有顺序，长度可变

> 数组

列表的实现方式之一

特点：

1. 大部分语言中，元素的类型一致
2. 具有索引，内存中连续空间，每个元素占用的空间大小一样

### 数组操作

> 读取元素

根据索引读取，时间复杂度`o(1)`

> 查找元素

根据索引查找，时间复杂度`o(n)`

> 插入元素

建议使用链表

> 删除元素

建议使用链表

### 例题

#### 寻找数组的中心索引

```java
/**
给你一个整数数组 nums ，请计算数组的 中心下标 。
数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。
如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。
如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。
输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。

作者：LeetCode
链接：https://leetcode.cn/leetbook/read/array-and-string/yf47s/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
*/
public int pivotIndex(int[] nums) {
        int sumLeft=0;
        int sumRight=0;
        int index=-1;
        for (int i = 0; i < nums.length; i++) {
            //左边
            for (int j = 0; j < i; j++) {
                sumLeft+=nums[j];

            }
            //右边
            for (int j = i+1; j <nums.length ; j++) {
                sumRight+=nums[j];

            }
            if(sumLeft==sumRight){
                index=i;
                break;
            }
            sumLeft=0;
            sumRight=0;
        }
        return index;
    }
```

#### 搜索插入位置

```

```

#### 合并区间

```

```

### 二维数组

本质上就是一维数组，其中第一维数组记录的是第二维数组的索引位置

注意：实际数组中的元素由于类型的不同会占用不同的字节数，因此相邻两个地址之间的差值可能不为1.

### 例题

#### 旋转矩阵

```

```

#### 零矩阵

```

```

#### 对角线遍历

```

```

## 字符串

### 字符串简介

字符串的基本操作对象通常是字符串整体或者其字串

字符串操纵比其他数据类型更加复杂（比如连接，比较）

> 比较函数

Java里面不能用`==`来比较，因为比较的是字符串地址；c++里面可以

> 连接操作

java因为字符串不可变，一般有两个方法

1. ` toCharArray `将其转化为字符数组
2. 使用其他数据结构，如`StringBUffer`

### 例题

#### 最长公共前缀

```

```

#### 最长回文子串

```

```

#### 最长回文子串

```

```

#### 翻转字符串里面的单词

```

```

### 双指针

情景一:`从两端向中间迭代数组，一个指针从头部开始，另一个指针从尾部开始`

**反转字符串**

```

```

**数组拆分**

```

```

**两数之和**

```

```

情景二：`使用两个不同步的指针解决问题，就是快慢指针，两个指针的运动方向是相同的，而不是相反的。解决问题的关键：确定两个指针的移动策略`

**长度最小的子数组**

```

```

